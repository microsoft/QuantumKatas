// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

//////////////////////////////////////////////////////////////////////
// This file contains reference solutions to all tasks.
// The tasks themselves can be found in Tasks.qs file.
// but feel free to look up the solution if you get stuck.
//////////////////////////////////////////////////////////////////////

namespace Quantum.Kata.KeyDistributionE91 {

    open Microsoft.Quantum.Arrays;
    open Microsoft.Quantum.Measurement;
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Random;


    //////////////////////////////////////////////////////////////////
    // Part I. Preparation
    //////////////////////////////////////////////////////////////////
	
    // Task 1.1. Entangled Pairs
    operation EntangledPairs_Reference (qsAlice : Qubit[], qsBob : Qubit[]) : Unit is Adj{
        Fact(Length(qsAlice) == Length(qsBob), "Alice and Bob should have the same number of qubits");

        for (i, j) in Zipped(qsAlice, qsBob) {
            H(i);
            CNOT(i, j);
        }
    }


    //////////////////////////////////////////////////////////////////
    // Part II. E91 Protocol
    //////////////////////////////////////////////////////////////////

    // Task 2.1 Rotate and Measure
    operation RotateAndMeasure_Reference (q : Qubit, basisIndex: Int) : Result {
        mutable result = Zero;
        let rotationAngle = PI() * IntAsDouble(basisIndex - 1) / 4.0;

        within {
            Ry(rotationAngle, q);
        } apply {
            set result = M(q);
        }

        return result;
    }

    // Task 2.2. Random Bases Array
    operation RandomBasesArray_Reference (basesIndices: Int[], N: Int) : Int[] {
        // ...
        mutable bases = [];

        for _ in 1..N {
            let randomIndex = DrawRandomInt(0, Length(basesIndices) - 1);
            set bases += [basesIndices[randomIndex]];
        }

        return bases;
    }

    // Task 2.3 Measure Qubit Arrays
    operation MeasureQubitArray_Reference (qs: Qubit[], basesIndices: Int[]) : Result[] {
        mutable results = [];

        for (q, b) in Zipped(qs, basesIndices) {
            let outcome = RotateAndMeasure_Reference(q,b);
            set results += [outcome];
        }

        return results;
    }

    // Task 2.4 Generate the shared key
    function GenerateSharedKey_Reference (basesAlice: Int[], basesBob: Int[], results: Result[]) : Bool[] {
        mutable key = [];

        for (a, b, r) in Zipped3(basesAlice, basesBob, results) {
            if a == b {
                set key += [ResultAsBool(r)];
            }
        }
        
        return key;
    }

    // Task 2.5 Putting it all together 
    operation T25_E91Protocol_Reference () : Unit {
        // 1. Alice and Bob are distributed arrays of entangled pairs
        let N = 10;
        use (qsAlice, qsBob) = (Qubit[N] ,Qubit[N]);
        EntangledPairs_Reference(qsAlice, qsBob);

        // 2. Alice and Bob choose random measurement bases
        let basesAlice = RandomBasesArray_Reference([1,2,3], N);
        let basesBob = RandomBasesArray_Reference([2,3,4], N);

        // 3. Measurements by Alice and Bob
        let resultsAlice = MeasureQubitArray_Reference(qsAlice, basesAlice);
        let resultsBob = MeasureQubitArray_Reference(qsBob, basesBob);

        // 4. Keys generated by Alice and Bob
        let keyAlice = GenerateSharedKey_Reference(basesAlice, basesBob, resultsAlice);
        let keyBob = GenerateSharedKey_Reference(basesAlice, basesBob, resultsBob);
        Message($"Alice's Key: {keyAlice}");
        Message($"Bob's Key:   {keyBob}\n");

        // Reset all qubits to |0⟩
        ResetAll(qsAlice + qsBob);
        
    }

    //////////////////////////////////////////////////////////////////
    // Part III. Eavesdropping
    //////////////////////////////////////////////////////////////////

    // Task 3.1 CHSH Correlation Value
    function CorrelationValue_Reference (basesAlice: Int[], basesBob: Int[], resultsAlice: Result[], resultsBob: Result[]) : Double {
        mutable expectationValues = [];
        
        for (i, j) in [(1,2), (1, 4), (3, 2), (3, 4)] {
            mutable sum = 0;
            mutable counter = 0;

            for idx in IndexRange(basesAlice) {
                if basesAlice[idx] == i and basesBob[idx] == j {
                    if resultsAlice[idx] == resultsBob[idx] {
                        set sum += 1;
                    } else {
                        set sum -= 1;
                    }
                    set counter += 1;
                }
            }
            if counter == 0 {
                set expectationValues += [0.0];
            } else {
                set expectationValues += [IntAsDouble(sum)/IntAsDouble(counter)];
            }
        }

        let s = expectationValues[0] 
            -  expectationValues[1]
            + expectationValues[2] 
            + expectationValues[3]; 

        return s;
    }

    // Task 3.2. Eavesdrop!
    operation Eavesdrop_Reference (qAlice : Qubit, qBob : Qubit, basis : Int) : (Result, Result) {
        Fact(basis == 2 or basis == 3, "Eve should measure in one of Alice's and Bob's compatible basis");

        let resultsAlice = RotateAndMeasure_Reference(qAlice, basis);
        let resultsBob = RotateAndMeasure_Reference(qBob, basis);

        return (resultsAlice, resultsBob);
    }

    // Task 3.3. Catch the eavesdropper
    operation T33_E91ProtocolWithEavesdropper_Reference () : Unit {
        // 1. Alice and Bob are distributed arrays of entangled pairs
        let N = 10;
        use (qsAlice, qsBob) = (Qubit[N] ,Qubit[N]);
        EntangledPairs_Reference(qsAlice, qsBob);

        // Eve eavesdrops on all qubits, guessing the basis at random
        for (qAlice, qBob) in Zipped(qsAlice, qsBob) {
            let _ = Eavesdrop_Reference(qAlice, qBob, DrawRandomInt(2,3));
        }

        // 2. Alice and Bob choose random measurement bases
        let basesAlice = RandomBasesArray_Reference([1,2,3], N);
        let basesBob = RandomBasesArray_Reference([2,3,4], N);

        // 3. Measurements by Alice and Bob
        let resultsAlice = MeasureQubitArray_Reference(qsAlice, basesAlice);
        let resultsBob = MeasureQubitArray_Reference(qsBob, basesBob);

        // 4. Keys generated by Alice and Bob
        let keyAlice = GenerateSharedKey_Reference(basesAlice, basesBob, resultsAlice);
        let keyBob = GenerateSharedKey_Reference(basesAlice, basesBob, resultsBob);
        Message($"Alice's Key: {keyAlice}");
        Message($"Bob's Key:   {keyBob}\n");

        // 5. Compute the CHSH correlation value
        let s = CorrelationValue_Reference(basesAlice, basesBob, resultsAlice, resultsBob);
        Message($"S = {s}");

        // Reset all qubits to |0⟩
        ResetAll(qsAlice + qsBob);

    }
}